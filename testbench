`include "uvm_macros.svh"
import uvm_pkg::*;

typedef enum bit [1:0] {readd = 0, writed = 1, rstdut = 2} oper_mode;

class transaction extends uvm_sequence_item;
  `uvm_object_utils(transaction)
  
  oper_mode op;
  logic wr;
  rand logic [6:0] addr;
  rand logic [7:0] din;
  logic [7:0] datard;
  
  function new(string name = "transaction");
    super.new(name);
  endfunction

  constraint addr_c {addr <= 10;} 
  
endclass

//////////////////////////////////////////////////////////

class write_data extends uvm_sequence#(transaction);
  `uvm_object_utils(write_data)
  
  transaction tr;
  
  function new(string name = "write_data");
    super.new(name);
  endfunction  
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      start_item(tr);
      assert(tr.randomize);
      tr.op = writed;
      `uvm_info("SEQ", $sformatf("MODE: WRITE ADDR: %0d DIN: %0d", tr.addr, tr.din), UVM_NONE);
      finish_item(tr);      
    end
  endtask
  
endclass

//////////////////////////////////////////////////////////

class read_data extends uvm_sequence#(transaction);
  `uvm_object_utils(read_data)
  
  transaction tr;
  
  function new(string name = "read_data");
    super.new(name);
  endfunction  
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      start_item(tr);
      assert(tr.randomize);
      tr.op = readd;
      `uvm_info("SEQ", $sformatf("MODE: READ ADDR: %0d", tr.addr), UVM_NONE);
      finish_item(tr);      
    end
  endtask
  
endclass

//////////////////////////////////////////////////////////

class reset_dut extends uvm_sequence#(transaction);
  `uvm_object_utils(reset_dut)
  
  transaction tr;
  
  function new(string name = "reset_dut");
    super.new(name);
  endfunction  
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      start_item(tr);
      assert(tr.randomize);
      tr.op = rstdut;
      `uvm_info("SEQ", $sformatf("MODE: RESET"), UVM_NONE);
      finish_item(tr);      
    end
  endtask
  
endclass

//////////////////////////////////////////////////////////

class driver extends uvm_driver#(transaction);
  `uvm_component_utils(driver)
  
  transaction tr;
  virtual i2c_i vif;
  
  function new(string name = "driver", uvm_component parent = null);
    super.new(name, parent);
  endfunction  
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    tr = transaction::type_id::create("tr");
    
    if(!uvm_config_db #(virtual i2c_i)::get(this,"","vif",vif))
      `uvm_error("DRV", "Unable to access Inteface");
  endfunction
  
  task reset_dut();
    vif.rst <= 1'b1;
    vif.wr <= 1'b0;
    vif.addr <= 0;
    vif.din <= 0;
    `uvm_info("DRV", "System Reset", UVM_MEDIUM);
    @(posedge vif.clk); 
    
  endtask
    
  task write_d();
      vif.rst <= 1'b0;
      vif.wr <= 1'b1;
      vif.addr <= tr.addr;
      vif.din <= tr.din;     
      `uvm_info("DRV", $sformatf("mode: WRITE addr: %0d din: %0d", tr.addr, tr.din), UVM_NONE);
    @(posedge vif.done); 
    
  endtask

  task read_d();
      vif.rst <= 1'b0;
      vif.wr <= 1'b0;
      vif.addr <= tr.addr;
      vif.din <= 0;      
      `uvm_info("DRV", $sformatf("mode: READ addr: %0d", tr.addr), UVM_NONE);
      @(posedge vif.done); 
    
  endtask
  
  virtual task run_phase(uvm_phase phase);
    forever begin
      seq_item_port.get_next_item(tr);

      if(tr.op == rstdut)
        reset_dut();
      else if(tr.op == writed)
        write_d();
      else
        read_d();

      seq_item_port.item_done();
    end
  endtask
  
endclass

//////////////////////////////////////////////////////////

class mon extends uvm_monitor;
  `uvm_component_utils(mon)
  
  transaction tr;
  virtual i2c_i vif;
  uvm_analysis_port #(transaction) send;
  
  function new(string name = "mon", uvm_component parent = null);
    super.new(name, parent);
  endfunction  
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    tr = transaction::type_id::create("tr");
    send = new("send", this);
    
    if(!uvm_config_db #(virtual i2c_i)::get(this,"","vif",vif))
      `uvm_error("MON", "Unable to access Inteface");
  endfunction
  
  virtual task run_phase(uvm_phase phase);
    forever begin
      @(posedge vif.clk);
      
      if(vif.rst) begin
        tr.op = rstdut;
        `uvm_info("MON", "SYSTEM RESET DETECTED", UVM_MEDIUM);
      end
        
      else if(vif.wr) begin
        @(posedge vif.done);
        tr.op = writed;
        tr.wr = 1;
        tr.addr = vif.addr;
        tr.din = vif.din;
        `uvm_info("MON", $sformatf("DATA WRITE addr: %0d data: %0d", tr.addr, tr.din), UVM_NONE);    
      end
      
      else begin
        @(posedge vif.done); 
        tr.op = readd;
        tr.wr = 0;
        tr.addr = vif.addr;
        tr.din = vif.din;
        tr.datard = vif.datard;
        `uvm_info("MON", $sformatf("DATA READ addr: %0d data: %0d", tr.addr, tr.datard), UVM_NONE);        
      end
      
      send.write(tr);

    end
  endtask
  
endclass

class sco extends uvm_scoreboard;
  `uvm_component_utils(sco)
  
  uvm_analysis_imp #(transaction, sco) recv;
  bit [7:0] arr[128] = '{default:0};
  bit [7:0] data_rd = 0;
  
  function new(string name = "sco", uvm_component parent = null);
    super.new(name, parent);
  endfunction  
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    recv = new("recv", this);
  endfunction
  
  virtual function void write(transaction tr);
    if(tr.op == rstdut) 
      `uvm_info("SCO", "SYSTEM RESET DETECTED", UVM_MEDIUM)
    
    else if(tr.op == writed) begin
      arr[tr.addr] = tr.din; 
      `uvm_info("SCO", $sformatf("DATA WRITE OP addr: %0d wdata: %0d arr_wr: %0d", tr.addr, tr.din, arr[tr.addr]), UVM_NONE);         
    end
    else begin
      data_rd = arr[tr.addr];

      if(tr.datard == data_rd) 
        `uvm_info("SCO", $sformatf("DATA MATCH: addr: %0d rdata: %0d arr_wr: %0d", tr.addr, tr.datard, data_rd), UVM_NONE)        
      else
        `uvm_info("SCO", $sformatf("TEST FAILED: addr: %0d rdata: %0d arr_wr: %0d", tr.addr, tr.datard, data_rd), UVM_NONE)     
    end
    
     $display("----------------------------------------------------------------");
  endfunction
  
endclass
      
//////////////////////////////////////////////////////////

class agent extends uvm_agent;
  `uvm_component_utils(agent)
  
  uvm_sequencer #(transaction) seqr;
  driver d;
  mon m;
  
  function new(string name = "agent", uvm_component parent = null);
    super.new(name, parent);
  endfunction  
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    seqr = uvm_sequencer#(transaction)::type_id::create("seqr", this);
    d = driver::type_id::create("d", this);
    m = mon::type_id::create("m", this);
  endfunction
  
  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    d.seq_item_port.connect(seqr.seq_item_export);
  endfunction
  
endclass
  
//////////////////////////////////////////////////////////

class env extends uvm_env;
  `uvm_component_utils(env)
  
  agent a;
  sco s;
  
  function new(string name = "env", uvm_component parent = null);
    super.new(name, parent);
  endfunction  
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    a = agent::type_id::create("a", this);
    s = sco::type_id::create("s", this);
  endfunction
  
  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    a.m.send.connect(s.recv);
  endfunction
  
endclass      
      
//////////////////////////////////////////////////////////
      
class test extends uvm_test;
  `uvm_component_utils(test)

  env e;
  
  reset_dut rstdut;
  write_data wdata;
  read_data rdata;
  
  function new(string name = "test", uvm_component parent);
    super.new(name, parent);
  endfunction  
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    e = env::type_id::create("e", this);
    
    wdata = write_data::type_id::create("wdata");
    rdata = read_data::type_id::create("rdata");
    rstdut = reset_dut::type_id::create("rstdut");
  endfunction
  
  virtual task run_phase(uvm_phase phase);
    phase.raise_objection(this);
    
    rstdut.start(e.a.seqr);
    
    wdata.start(e.a.seqr);
    
    rdata.start(e.a.seqr);
    
    phase.drop_objection(this);
  endtask
  
endclass 

//////////////////////////////////////////////////////////

module tb;
  
  i2c_i vif();
  i2c_mem dut(.clk(vif.clk), .rst(vif.rst), .wr(vif.wr), .addr(vif.addr), .din(vif.din), .datard(vif.datard), .done(vif.done));
  
  initial begin
    vif.clk <= 0;     
  end
  
  always #10 vif.clk <= ~vif.clk;
  
  initial begin
    uvm_config_db #(virtual i2c_i)::set(null,"*","vif",vif);
    run_test("test");
  end
  
endmodule
      
      
